---
title: "Students-Perfomance E-Business"
output:
  pdf_document: default
  html_document:
    keep_md: true
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*.

```{r}

# Install and load necessary libraries
if (!requireNamespace("caret", quietly = TRUE)) {
  install.packages("caret")
}
if (!requireNamespace("skimr", quietly = TRUE)) {
  install.packages("skimr")
}
if (!requireNamespace("tidyverse", quietly = TRUE)) {
  install.packages("tidyverse")
}
if (!requireNamespace("janitor", quietly = TRUE)) {
  install.packages("janitor")
}
if (!requireNamespace("themis", quietly = TRUE)) {
  install.packages("themis")
}
if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}


library(caret)
library(themis)
library(skimr)
library(tidyverse)
library(janitor)
library(dplyr)
library(ggplot2)


# Load the datasets
train <- read.csv("data/train.csv", stringsAsFactors = TRUE)
test <- read.csv("data/test.csv", stringsAsFactors = TRUE)

# Display the first few rows of the train dataset
head(train)

# Get a summary of the dataset
glimpse(train)

# Skim the dataset for a comprehensive overview
skim(train)
```

## Data Visualization

### General Distribution of Columns

The code underneath prepares a data set by converting selected columns to factor variables and creates various bar plots and histograms to visualize the distribution of different variables.

```{r}
# Convert appropriate columns to factors
test$Gender <- factor(test$Gender)
test$Job.Role <- factor(test$Job.Role)
test$Work.Life.Balance <-
  factor(test$Work.Life.Balance,
         levels = c("Poor", "Below Average", "Good", "Excellent"))
test$Job.Satisfaction <-
  factor(test$Job.Satisfaction,
         levels = c("Very Low", "Low", "Medium", "High"))
test$Performance.Rating <-
  factor(test$Performance.Rating,
         levels = c("Low", "Below Average", "Average", "High"))
test$Education.Level <-
  factor(
    test$Education.Level,
    levels = c(
      "High School",
      "Associate Degree",
      "Bachelor’s Degree",
      "Master’s Degree",
      "PhD"
    )
  )
test$Marital.Status <- factor(test$Marital.Status)

test$Job.Level <-
  factor(test$Job.Level, levels = c("Entry", "Mid", "Senior"))

test$Company.Size <-
  factor(test$Company.Size, levels = c("Small", "Medium", "Large"))

test$Remote.Work <- factor(test$Remote.Work)

test$Leadership.Opportunities <-
  factor(test$Leadership.Opportunities)

test$Innovation.Opportunities <-
  factor(test$Innovation.Opportunities)

test$Company.Reputation <-
  factor(test$Company.Reputation,
         levels = c("Very Poor", "Poor", "Good", "Excellent"))

test$Employee.Recognition <-
  factor(test$Employee.Recognition,
         levels = c("Very Low", "Low", "Medium", "High"))

# Function to create bar plots for categorical variables
create_bar_plot <- function(df, col_name, title) {
  ggplot(df, aes(x = .data[[col_name]])) +
    geom_bar(fill = "skyblue", color = "black") +
    labs(title = title,
         x = col_name,
         y = "Count") +
    theme_minimal() +
    theme(text = element_text(size = 12),
          axis.text.x = element_text(angle = 45, hjust = 1))
}

# Function to create histograms for numerical variables
create_hist_plot <- function(df, col_name, title) {
  ggplot(df, aes(x = .data[[col_name]])) +
    geom_histogram(bins = 30,
                   fill = "skyblue",
                   color = "black") +
    labs(title = title,
         x = col_name,
         y = "Count") +
    theme_minimal() +
    theme(text = element_text(size = 12))
}

# Plotting each column
plot_list <- list(
  create_hist_plot(test, "Age", "Distribution of Age"),
  create_bar_plot(test, "Gender", "Distribution of Gender"),
  create_hist_plot(test, "Years.at.Company", "Distribution of Years at Company"),
  create_hist_plot(test, "Monthly.Income", "Distribution of Monthly Income"),
  create_bar_plot(test, "Job.Role", "Distribution of Job Role"),
  create_bar_plot(test, "Work.Life.Balance", "Distribution of Work-Life Balance"),
  create_bar_plot(test, "Job.Satisfaction", "Distribution of Job Satisfaction"),
  create_bar_plot(
    test,
    "Performance.Rating",
    "Distribution of Performance Rating"
  ),
  create_hist_plot(
    test,
    "Number.of.Promotions",
    "Distribution of Number of Promotions"
  ),
  create_hist_plot(test, "Distance.from.Home", "Distribution of Distance from Home"),
  create_bar_plot(test, "Education.Level", "Distribution of Education Level"),
  create_bar_plot(test, "Marital.Status", "Distribution of Marital Status"),
  create_bar_plot(test, "Job.Level", "Distribution of Job Level"),
  create_bar_plot(test, "Company.Size", "Distribution of Company Size"),
  create_hist_plot(test, "Company.Tenure", "Distribution of Company Tenure"),
  create_bar_plot(test, "Remote.Work", "Distribution of Remote Work"),
  create_bar_plot(
    test,
    "Leadership.Opportunities",
    "Distribution of Leadership Opportunities"
  ),
  create_bar_plot(
    test,
    "Innovation.Opportunities",
    "Distribution of Innovation Opportunities"
  ),
  create_bar_plot(
    test,
    "Company.Reputation",
    "Distribution of Company Reputation"
  ),
  create_bar_plot(
    test,
    "Employee.Recognition",
    "Distribution of Employee Recognition"
  ),
  create_bar_plot(test, "Attrition", "Distribution of Attrition")
)

# Print all plots
for (p in plot_list) {
  print(p)
}

rm(plot_list)
rm(p)
rm(create_bar_plot)
rm(create_hist_plot)
```

## EDA - Exploratory Data Analysis

Exploratory Data Analysis (EDA) is an essential step in the data analysis process. It involves examining and understanding the data to uncover patterns, relationships, and potential issues. EDA utilizes descriptive statistics and data visualization techniques to gain insights and make informed decisions.

```{r}
head(test)
```

### Work life balance by Attrition

This code calculates the count and percentage of attrition for each category of work-life balance in the "test" data set and creates a bar chart to visualize the results.

```{r}
# Calculate the count and percentage of attrition for each category of Work life balance
attrition_counts <- test %>%
  group_by(Work.Life.Balance, Attrition) %>%
  summarise(Count = n()) %>%
  mutate(Percentage = Count / sum(Count) * 100)

# Create the bar chart for Work-Life Balance with percentages
ggplot(attrition_counts, aes(x = Work.Life.Balance, y = Count, fill = factor(Attrition))) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = paste0(round(Percentage, 1), "%")), 
            position = position_stack(vjust = 0.5), size = 3) +
  labs(title = "Attrition by Work-Life Balance",
       x = "Work-Life Balance",
       y = "Count",
       fill = "Attrition") +
  scale_fill_manual(values = c("skyblue", "orange"),
                    labels = c("Stayed", "Left")) +
  theme_minimal()

rm(attrition_counts)
```

### Education Level by Attrition

This code calculates the count and percentage of attrition for each category of education level in the "test" data set and creates a bar chart to visualize the results.

```{r}
# Calculate the count and percentage of attrition for each category of Education Level
attrition_counts_edu <- test %>%
  group_by(Education.Level, Attrition) %>%
  summarise(Count = n()) %>%
  mutate(Percentage = Count / sum(Count) * 100)

# Create the bar chart for Education Level with percentages
ggplot(attrition_counts_edu, aes(x = Education.Level, y = Count, fill = factor(Attrition))) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = paste0(round(Percentage, 1), "%")), 
            position = position_stack(vjust = 0.5), size = 3, hjust = 0.5) +
  labs(title = "Attrition by Education Level",
       x = "Education Level",
       y = "Count",
       fill = "Attrition") +
  scale_fill_manual(values = c("skyblue", "orange"),
                    labels = c("Stayed", "Left")) +
  scale_x_discrete(labels = c("High School", "Associate Degree", "Bachelor's Degree", "Master's Degree", "PhD")) +
  theme_minimal()

rm(attrition_counts_edu)
```

### Job Satisfaction by Attrition

This code calculates the count and percentage of attrition for each category of job satisfaction in the "test" data set and creates a bar chart to visualize the results.

```{r}
# Calculate the count and percentage of attrition for each category of Job Satisfaction
attrition_counts_satisfaction <- test %>%
  group_by(Job.Satisfaction, Attrition) %>%
  summarise(Count = n()) %>%
  mutate(Percentage = Count / sum(Count) * 100)

# Create the bar chart for Job Satisfaction with percentages
ggplot(attrition_counts_satisfaction, aes(x = Job.Satisfaction, y = Count, fill = factor(Attrition))) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = paste0(round(Percentage, 1), "%")), 
            position = position_stack(vjust = 0.5), size = 3, hjust = 0.5) +
  labs(title = "Attrition by Job Satisfaction",
       x = "Job Satisfaction",
       y = "Count",
       fill = "Attrition") +
  scale_fill_manual(values = c("skyblue", "orange"),
                    labels = c("Stayed", "Left")) +
  scale_x_discrete(labels = c("Very Low", "Low", "Medium", "High")) +
  theme_minimal()

rm(attrition_counts_satisfaction)
```

### Job Level vs Attrition

This code calculates the count and percentage of attrition for each job level category in the "test" data set. It then creates a bar chart to visualize the count of attrition by job level for instances where attrition is "Left."

```{r}
attrition_counts <- test %>%
  group_by(Job.Level, Attrition) %>%
  summarise(Count = n()) %>%
  mutate(Percentage = Count / sum(Count) * 100)
# Filter the dataset to include only instances where attrition is "Left"
left_attrition <- test[test$Attrition == "Left", ]

# Create the bar chart
ggplot(left_attrition, aes(x = Job.Level)) +
  geom_bar(fill = "skyblue") +
  labs(title = "Attrition by Job Level (Left Only)",
       x = "Job Level",
       y = "Attrition Count") +
  theme_minimal()

rm(attrition_counts)
```

### Remote Work vs Attrition

This code creates a bar chart to visualize the count of attrition by remote work for instances where attrition is "Left" in the data set.

```{r}
# Filter the dataset to include only instances where attrition is "Left"
left_attrition <- test[test$Attrition == "Left", ]

# Create the bar chart
ggplot(left_attrition, aes(x = Remote.Work)) +
  geom_bar(fill = "skyblue") +
  labs(title = "Attrition by Remote Work (Left Only)",
       x = "Remote Work",
       y = "Attrition Count") +
  theme_minimal()

rm(left_attrition)
```

The Numbers 1 and 2 stand for **Attrition (1)** and **No Attrition (2)**

## Job Level & Remote Work vs Attrition

This code creates a stacked bar chart to visualize the count of attrition by job level and remote work in the data set.

```{r}
# Calculate the count of attrition for each combination of Job Level, Remote Work, and Attrition
attrition_counts <- test %>%
  group_by(Job.Level, Remote.Work, Attrition) %>%
  summarise(Count = n())

# Create the stacked bar chart with Job Level, Remote Work, and Attrition
ggplot(attrition_counts, aes(x = Job.Level, y = Count, fill = Remote.Work)) +
  geom_bar(stat = "identity") +
  labs(title = "Attrition Count by Job Level and Remote Work",
       x = "Job Level",
       y = "Count",
       fill = "Remote Work") +
  facet_wrap(~ Attrition) +
  theme_minimal()

rm(attrition_counts)
```

### Marital Status vs Attrition

This code creates a bar chart to visualize the count of attrition by marital status for instances where attrition is "Left" in the data set.

```{r}
# Filter the dataset to include only instances where attrition is "Left"
left_attrition <- test[test$Attrition == "Left", ]

# Create the bar chart
ggplot(left_attrition, aes(x = Marital.Status)) +
  geom_bar(fill = "skyblue") +
  labs(title = "Attrition by Marital Status (Left Only)",
       x = "Marital Status",
       y = "Attrition Count") +
  theme_minimal()

rm(left_attrition)
```

### Distance from Home vs Attrition

This code creates a bar chart to visualize the count of attrition by distance from home in the data set.

```{r}
# Convert Distance.from.Home to factor
test$Distance.from.Home <- factor(test$Distance.from.Home)

ggplot(test, aes(x = Distance.from.Home, fill = as.factor(Attrition))) +
  geom_bar() +
  labs(title = "Attrition by Distance from Home",
       x = "Distance from Home",
       y = "Count",
       fill = "Attrition") +
  theme_minimal()
```

### Number of Promotions vs Attrition

This code creates a bar chart to visualize the count of attrition by the number of promotions in the data set.

```{r}
# Convert Number.of.Promotions to factor
test$Number.of.Promotions <- factor(test$Number.of.Promotions)

ggplot(test, aes(x = Number.of.Promotions, fill = as.factor(Attrition))) +
  geom_bar() +
  labs(title = "Attrition by Number of Promotions",
       x = "Number of Promotions",
       y = "Count",
       fill = "Attrition") +
  theme_minimal()
```

### Gender vs Attrition

This code creates a bar chart to visualize the count of attrition by gender in the data set.

```{r}
# Convert Gender to factor
 test$Gender <- factor(test$Gender)

 ggplot(test, aes(x = Gender, fill = as.factor(Attrition))) +
   geom_bar() +
   labs(title = "Attrition by Gender",
        x = "Gender",
        y = "Count",
        fill = "Attrition") +
   theme_minimal()
```

## Age vs Attrition

This code creates a box plot to compare the age distribution between different attrition statuses in the data set.

```{r}
# Box plot for Age vs Attrition
ggplot(test, aes(x = as.factor(Attrition), y = Age)) + 
  geom_boxplot(fill = "skyblue", color = "black") + 
  labs(title = "Box Plot of Age by Attrition Status",
       x = "Attrition (1 = Stayed, 2 = Left)",
       y = "Age (Years)") +
  theme_minimal()
```

```{r}


# Check for missing values
train_missing <- train %>% summarise_all(~sum(is.na(.)))
test_missing <- test %>% summarise_all(~sum(is.na(.)))
 
# Print missing values
print(train_missing)
print(test_missing)

```

We found that our dataset has no missing values at all. However to be future proofed, we prepared some handling for missing values below:

```{r}
# # Handle missing values
# # For numeric columns, fill missing values with median
# fill_missing_numeric <- function(df) {
#   df %>% mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .)))
# }
# 
# # For categorical columns, fill missing values with mode
# fill_missing_categorical <- function(df) {
#   df %>% mutate(across(where(is.character), ~ifelse(is.na(.), names(sort(table(.), decreasing = TRUE))[1], .)))
# }
# 
# # Apply the functions to train and test data
# train <- train %>% fill_missing_numeric() %>% fill_missing_categorical()
# test <- test %>% fill_missing_numeric() %>% fill_missing_categorical()
# 
# # Check for remaining missing values
# sum(is.na(train))
# sum(is.na(test))

```

##Data Cleaning

```{r}
# Clean column names
train <- train %>% clean_names()
test <- test %>% clean_names()

# Handle duplicates
train <- train %>% distinct()
test <- test %>% distinct()

# # Correct inconsistencies --> do more if wanted?? -Dont think we need this for now. 
# # Standardize categorical levels
# train <- train %>% mutate(job_role = str_to_lower(job_role))
# test <- test %>% mutate(job_role = str_to_lower(job_role))

# Verify corrections
unique(train$job_role)
unique(test$job_role)

```

## Outlier detection and treatment

Using IQR to detect and cap outliers #TODO: Graphic and optimizing

```{r}
cap_outliers <- function(x) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = TRUE)
  caps <- quantile(x, probs=c(.05, .95), na.rm = TRUE)
  H <- 1.5 * IQR(x, na.rm = TRUE)
  lower_bound <- qnt[1] - H
  upper_bound <- qnt[2] + H
  x[x < lower_bound] <- caps[1]
  x[x > upper_bound] <- caps[2]
  return(x)
}

# Function to count outliers
count_outliers <- function(x) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = TRUE)
  H <- 1.5 * IQR(x, na.rm = TRUE)
  sum(x < (qnt[1] - H)) + sum(x > (qnt[2] + H))
}

# Apply the functions to train and test data
train_outlier_counts <- train %>% select(where(is.numeric)) %>% map_int(count_outliers)
test_outlier_counts <- test %>% select(where(is.numeric)) %>% map_int(count_outliers)

# Cap outliers
train <- train %>% mutate_if(is.numeric, cap_outliers)


# Display the number of outliers detected and capped
print(train_outlier_counts)
print(test_outlier_counts)


# # Load necessary libraries
# library(ggplot2)
# library(dplyr)
# 
# 
# 
# # Function to cap outliers based on the given R code
# cap_outliers <- function(x) {
#   qnt <- quantile(x, probs=c(.25, .75), na.rm = TRUE)
#   H <- 1.5 * IQR(x, na.rm = TRUE)
#   lower_bound <- qnt[1] - H
#   upper_bound <- qnt[2] + H
#   caps <- quantile(x, probs=c(.05, .95), na.rm = TRUE)
#   x[x < lower_bound] <- caps[1]
#   x[x > upper_bound] <- caps[2]
#   return(x)
# }
# 
# # Function to count outliers
# count_outliers <- function(x) {
#   qnt <- quantile(x, probs=c(.25, .75), na.rm = TRUE)
#   H <- 1.5 * IQR(x, na.rm = TRUE)
#   sum(x < (qnt[1] - H)) + sum(x > (qnt[2] + H))
# }
# 
# # Apply the outlier counting function to the Monthly Income column
# monthly_income_outliers <- count_outliers(train$monthly_income)
# 
# # Apply the capping function to the Monthly Income column
# train$monthly_income_capped <- cap_outliers(train$monthly_income)
# 
# # Plot the Monthly Income before capping including the Interquartile ranges and the outliers
# ggplot(train, aes(x = monthly_income)) +
#   geom_boxplot() +
#   ggtitle('Monthly Income Before Capping') +
#   xlab('Monthly Income')
# 
# # Display the number of outliers detected
# print(monthly_income_outliers)


#---------------------------------

```

```{r}
# Check the structure of the dataset to confirm column names
str(train)

# Print the first few rows of the dataset to verify column names
head(train)
```

```{r}
# Encode categorical variables using one-hot encoding
train <- train %>%
  mutate(across(where(is.character), as.factor)) %>%
  mutate(across(where(is.factor), as.integer))

test <- test %>%
  mutate(across(where(is.character), as.factor)) %>%
  mutate(across(where(is.factor), as.integer))

# Display structure after encoding
str(train)
str(test)

```

```{r}
# Normalize numerical features
num_cols <- train %>% select(where(is.numeric)) %>% colnames()

train[num_cols] <- scale(train[num_cols])
test[num_cols] <- scale(test[num_cols])

# Display summary after normalization
summary(train[num_cols])
summary(test[num_cols])
```

```{r}
library(themis)
# Convert target variable to factor
train <- train %>%
  mutate(Attrition = as.factor(Attrition))

# Check for imbalanced data in the target variable
table(train$attrition)

# Handle imbalanced data using SMOTE from themis package
rec <- recipe(Attrition ~ ., data = train) %>%
  step_smote(Attrition)

train_balanced <- prep(rec, training = train) %>% bake(new_data = NULL)

# Display summary of balanced data
table(train_balanced$Attrition)

```

# Remove redundant features - check later if we want this

```{r}
# # Using nearZeroVar function from caret package to identify near zero variance predictors
# nzv <- nearZeroVar(train_balanced, saveMetrics = TRUE)
# nzv <- rownames(nzv[nzv$nzv == TRUE,])
# 
# train_balanced <- train_balanced %>% select(-all_of(nzv))
# test <- test %>% select(-all_of(nzv))
# 
# # Display structure after removing redundant features
# str(train_balanced)
# str(test)

```

# Check multicollinearity using Variance Inflation Factor (VIF) #TODO: Output of features to remove (and manual removal??)

```{r}
# library(car)
# library(dplyr) 
# # Check multicollinearity using Variance Inflation Factor (VIF)
# # Ensure all predictor variables are numeric
# train_balanced <- train_balanced %>%
#   mutate(across(where(is.factor), as.numeric))
# 
# # Select only numeric columns for VIF calculation
# num_vars <- train_balanced %>% select(where(is.numeric)) %>% colnames()
# 
# # Calculate VIF for each numeric feature
# vif_values <- vif(lm(attrition ~ ., data = train_balanced))
# 
# # Print VIF values
# print(vif_values)
# 
# # Remove features with VIF greater than a threshold (e.g., 5 or 10)
# high_vif <- names(vif_values[vif_values > 5])
# train_balanced <- train_balanced %>% select(-all_of(high_vif))
# test <- test %>% select(-all_of(high_vif))
# 
# # Display structure after removing high VIF features
# str(train_balanced)
# str(test)

# library(car)
# library(dplyr)
# 
# # Check multicollinearity using Variance Inflation Factor (VIF)
# # Ensure all predictor variables are numeric
# train_balanced <- train_balanced %>%
#   mutate(across(where(is.factor), as.numeric))
# 
# # Select only numeric columns for VIF calculation
# num_vars <- train_balanced %>% select(where(is.numeric)) %>% colnames()
# 
# # Calculate VIF for each numeric feature
# vif_values <- vif(lm(attrition ~ ., data = train_balanced))
# 
# # Print VIF values
# print(vif_values)
# 
# # Remove features with VIF greater than a threshold (e.g., 5 or 10)
# high_vif <- names(vif_values[vif_values > 5])
# train_balanced <- train_balanced %>% select(-all_of(high_vif))
# test <- test %>% select(-all_of(high_vif))
# 
# # Display structure after removing high VIF features
# str(train_balanced)
# str(test)
# 
# # Output features removed due to high VIF
# cat("Features removed due to high VIF:\n")
# print(high_vif)
# 

```

```{r}
# Save the cleaned data for future use
write_csv(train_balanced, "data/processed_train.csv")
write_csv(test, "data/processed_test.csv")

```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
