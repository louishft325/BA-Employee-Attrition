---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
library(skimr)
library(tidyverse)
library(janitor)

# Load the datasets
train <- read_csv("data/train.csv")
test <- read_csv("data/test.csv")

# Display the first few rows of the train dataset
head(train)

# Get a summary of the dataset
glimpse(train)

# Skim the dataset for a comprehensive overview
skim(train)
```

```{r}
# Clean column names
train <- train %>% clean_names()
test <- test %>% clean_names()

# Check for missing values
train_missing <- train %>% summarise_all(~sum(is.na(.)))
test_missing <- test %>% summarise_all(~sum(is.na(.)))

# Print missing values
print(train_missing)
print(test_missing)

```
## Outlier detection and treatment  
Using IQR to detect and cap outliers
```{r}
cap_outliers <- function(x) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = TRUE)
  caps <- quantile(x, probs=c(.05, .95), na.rm = TRUE)
  H <- 1.5 * IQR(x, na.rm = TRUE)
  lower_bound <- qnt[1] - H
  upper_bound <- qnt[2] + H
  x[x < lower_bound] <- caps[1]
  x[x > upper_bound] <- caps[2]
  return(x)
}

# Function to count outliers
count_outliers <- function(x) {
  qnt <- quantile(x, probs=c(.25, .75), na.rm = TRUE)
  H <- 1.5 * IQR(x, na.rm = TRUE)
  sum(x < (qnt[1] - H)) + sum(x > (qnt[2] + H))
}

# Apply the functions to train and test data
train_outlier_counts <- train %>% select(where(is.numeric)) %>% map_int(count_outliers)
test_outlier_counts <- test %>% select(where(is.numeric)) %>% map_int(count_outliers)

# Cap outliers
train <- train %>% mutate_if(is.numeric, cap_outliers)
test <- test %>% mutate_if(is.numeric, cap_outliers)

# Display the number of outliers detected and capped
print(train_outlier_counts)
print(test_outlier_counts)

```


```{r}
# Encode categorical variables using one-hot encoding
train <- train %>%
  mutate(across(where(is.character), as.factor)) %>%
  mutate(across(where(is.factor), as.integer))

test <- test %>%
  mutate(across(where(is.character), as.factor)) %>%
  mutate(across(where(is.factor), as.integer))

# Display structure after encoding
str(train)
str(test)

```
```{r}
# Normalize numerical features
num_cols <- train %>% select(where(is.numeric)) %>% colnames()

train[num_cols] <- scale(train[num_cols])
test[num_cols] <- scale(test[num_cols])

# Display summary after normalization
summary(train[num_cols])
summary(test[num_cols])
```


```{r}
library(themis)
# Ensure the target variable is a factor
train <- train %>%
  mutate(attrition = as.factor(attrition))

# Check for imbalanced data in the target variable
table(train$attrition)

# Handle imbalanced data using SMOTE from themis package
rec <- recipe(attrition ~ ., data = train) %>%
  step_smote(attrition)

train_balanced <- prep(rec, training = train) %>% bake(new_data = NULL)

# Display summary of balanced data
table(train_balanced$attrition)

```
```{r}
# Remove redundant features
# Using nearZeroVar function from caret package to identify near zero variance predictors
nzv <- nearZeroVar(train_balanced, saveMetrics = TRUE)
nzv <- rownames(nzv[nzv$nzv == TRUE,])

train_balanced <- train_balanced %>% select(-all_of(nzv))
test <- test %>% select(-all_of(nzv))

# Display structure after removing redundant features
str(train_balanced)
str(test)

```

```{r}
# Save the cleaned data for future use
write_csv(train_balanced, "data/processed_train.csv")
write_csv(test, "data/processed_test.csv")

# Confirm files are saved
file.exists("data/processed_train.csv")
file.exists("data/processed_test.csv")

```


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
